<!DOCTYPE html>
<html>
  <head>
    <title>Title</title>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
    <style type="text/css" media="screen">
      /* Slideshow styles */
    </style>
  </head>
  <body>
    <textarea id="source">

# About this class

The first few weeks will cover basic syntax and concepts, then we'll start to open it up with more exercises.

Some examples will be given as if written in the interpreter and others as if written in a source file.

Having an interpreter available makes it easy to explore a problem space.

---

# Why Scala?

* Expressive
    * First-class functions
    * Closures
* Concise
    * Type inference
    * Literal syntax for function creation
* Java interoperability
    * Can reuse java libraries
    * Can reuse java tools
    * No performance penalty

---

# How Scala?

* Compiles to java bytecode
* Works with any standard JVM
    * Or even some non-standard JVMs like Dalvik
    * Scala compiler written by author of Java compiler

---

# Think Scala

Scala is not just a nicer Java.  You should learn it with a fresh mind- you will get more out of these classes.

---

# Start the Interpreter

Start the included <code>sbt console</code>.

```scala
$ sbt console

[...]

Welcome to Scala version 2.8.0.final (Java HotSpot(TM) 64-Bit Server VM, Java 1.6.0_20).
Type in expressions to have them evaluated.
Type :help for more information.

scala>
```


---

# Expressions

```scala
scala> 1 + 1
res0: Int = 2
```

res0 is an automatically created value name given by the interpreter to the result of your expression.  It has the type Int and contains the Integer 2.

(Almost) everything in Scala is an expression.

---

# Values

You can give the result of an expression a name.

```scala
scala> val two = 1 + 1
two: Int = 2
```

You cannot change the binding to a val.

```scala
scala> two = 2
<console>:8: error: reassignment to val
       two = 2
```
---

# Variables

If you need to change the binding, you can use a <code>var</code> instead.

```scala
scala> var name = "steve"
name: java.lang.String = steve

scala> name = "marius"
name: java.lang.String = marius
```

---

# Equality

Scala  has both reference and value equality.

```scala
scala> val foo = new String("foobar")
foo: java.lang.String = foobar

scala> val bar = new String("foobar")
bar: java.lang.String = foobar

scala> foo == bar
res9: Boolean = true

scala> foo.eq(bar)
res10: Boolean = false
```

---

# Functions

You can create functions with def.

```scala
scala> def addOne(m: Int): Int = m + 1
addOne: (m: Int)Int
```

In Scala, you need to specify the type signature for function parameters.  The interpreter happily repeats the type signature back to you.

```scala
scala> val three = addOne(2)
three: Int = 3
```

You can leave off parens on functions with no arguments.

```scala
scala> def three() = 1 + 2
three: ()Int

scala> three()
res2: Int = 3

scala> three
res3: Int = 3
```

---

# Anonymous Functions

You can create anonymous functions.

```scala
scala> (x: Int) => x + 1
res2: (Int) => Int = <function1>
```

This function adds 1 to an Int named x.

```scala
scala> res2(1)
res3: Int = 2
```

You can pass anonymous functions around or save them into vals.

```scala
scala> val addOne = (x: Int) => x + 1
addOne: (Int) => Int = <function1>

scala> addOne(1)
res4: Int = 2
```

---

# Functions (ctd.)

If your function is made up of many expressions, you can use {} to give yourself some breathing room.

```scala
def timesTwo(i: Int): Int = {
  println("hello world")
  i * 2
}
```

This is also true of an anonymous function.

```scala
scala> { i: Int =>
  println("hello world")
  i * 2
}
res0: (Int) => Int = <function1>
```

You will see this syntax often used when passing an anonymous function as an argument.

---

# Partial application

You can partially apply a function with an underscore, which gives you another function. Scala uses the underscore to mean different things in different contexts, but you can usually think of it as an unnamed magical wildcard. In the context of <code>{ _ + 2 }</code> it means an unnamed parameter. You can use it like so:

```scala
scala> def adder(m: Int, n: Int) = m + n
adder: (m: Int,n: Int)Int
```

```scala
scala> val add2 = adder(2, _:Int)
add2: (Int) => Int = <function1>

scala> add2(3)
res50: Int = 5
```

You can partially apply any argument in the argument list, not just the last one.

---

# Curried functions

Sometimes it makes sense to let people apply some arguments to your function now and others later.

Here's an example of a function that lets you build multipliers of two numbers together. At one call site, you'll decide which is the multiplier and at a later call site, you'll choose a multiplicand.

```scala
scala> def multiply(m: Int)(n: Int): Int = m * n
multiply: (m: Int)(n: Int)Int
```

You can call it directly with both arguments.

```scala
scala> multiply(2)(3)
res0: Int = 6
```

You can fill in the first parameter and partially apply the second.

```scala
scala> val timesTwo = multiply(2) _
timesTwo: (Int) => Int = <function1>

scala> timesTwo(3)
res1: Int = 6
```

You can take any function of multiple arguments and curry it. Let's try with our earlier <code>adder</code>

```scala
scala> (adder _).curried
res1: (Int) => (Int) => Int = <function1>
```

---

# Variable length arguments

There is a special syntax for methods that can take parameters of a repeated type. To apply String's <code>capitalize</code> function to several strings, you might write:

```scala
def capitalizeAll(args: String*) = {
  args.map { arg =>
    arg.capitalize
  }
}

scala> capitalizeAll("rarity", "applejack")
res2: Seq[String] = ArrayBuffer(Rarity, Applejack)
```

---

# Classes

```scala
scala> class Calculator {
     |   val brand: String = "HP"
     |   def add(m: Int, n: Int): Int = m + n
     | }
defined class Calculator

scala> val calc = new Calculator
calc: Calculator = Calculator@e75a11

scala> calc.add(1, 2)
res1: Int = 3

scala> calc.brand
res2: String = "HP"
```

Contained are examples are defining methods with def and fields with val.  Methods are just functions that can access the state of the class.

---

# Constructor

Constructors aren't special methods, they are the code outside of method definitions in your class.  Let's extend our Calculator example to take a constructor argument and use it to initialize internal state.

```scala
class Calculator(brand: String) {
  /*
   * A constructor.
   */
  val color: String = if (brand == "TI") {
    "blue"
  } else if (brand == "HP") {
    "black"
  } else {
    "white"
  }

  // An instance method.
  def add(m: Int, n: Int): Int = m + n
}
```

Note the two different styles of comments.

You can use the constructor to construct an instance:

```scala
scala> val calc = new Calculator("HP")
calc: Calculator = Calculator@1e64cc4d

scala> calc.color
res0: String = black
```

---

# Expressions

Our BasicCalculator example gave an example of how Scala is expression-oriented.  The value color was bound based on an if/else expression. Scala is highly expression-oriented: most things are expressions rather than statements.

---

# Aside: Functions vs Methods

Functions and methods are largely interchangeable. Because functions and methods are so similar, you might not remember whether that <em>thing</em> you call is a function or a method. When you bump into a difference between methods and functions, it might confuse you.

```scala
scala> class C {
     |   var acc = 0
     |   def minc = { acc += 1 }
     |   val finc = { () => acc += 1 }
     | }
defined class C

scala> val c = new C
c: C = C@1af1bd6

scala> c.minc // calls c.minc()

scala> c.finc // returns the function as a value:
res2: () => Unit = <function0>
```

When you can call one "function" without parentheses but not another, you might think <em>Whoops, I thought I knew how Scala functions worked, but I guess not. Maybe they sometimes need parentheses?</em> You might understand functions, but be using a method.

In practice, you can do great things in Scala while remaining hazy on the difference between methods and functions. If you're new to Scala and read [explanations of the differences](https://www.google.com/search?q=difference+scala+function+method), you might have trouble following them. That doesn't mean you're going to have trouble using Scala. It just means that the difference between functions and methods is subtle enough such that explanations tend to dig into deep parts of the language.

---

# Inheritance

```scala
class ScientificCalculator(brand: String) extends Calculator(brand) {
  def log(m: Double, base: Double) = math.log(m) / math.log(base)
}
```

*See Also* Effective Scala points out that a [Type alias](http://twitter.github.com/effectivescala/#Types%20and%20Generics-Type%20aliases) is better than <code>extends</code> if the subclass isn't actually different from the superclass. A Tour of Scala describes [Subclassing](http://www.scala-lang.org/node/125).

---

# Overloading methods

```scala
class EvenMoreScientificCalculator(brand: String) extends ScientificCalculator(brand) {
  def log(m: Int): Double = log(m, math.exp(1))
}
```

---

# Abstract Classes

You can define an <em>abstract class</em>, a class that defines some methods but does not implement them. Instead, subclasses that extend the abstract class define these methods. You can't create an instance of an abstract class.

```scala
scala> abstract class Shape {
     |   def getArea():Int    // subclass should define this
     | }
defined class Shape

scala> class Circle(r: Int) extends Shape {
     |   def getArea():Int = { r * r * 3 }
     | }
defined class Circle

scala> val s = new Shape
<console>:8: error: class Shape is abstract; cannot be instantiated
       val s = new Shape
               ^

scala> val c = new Circle(2)
c: Circle = Circle@65c0035b
```

---

# Traits

<code>traits</code> are collections of fields and behaviors that you can extend or mixin to your classes.

```scala
trait Car {
  val brand: String
}

trait Shiny {
  val shineRefraction: Int
}
```

```scala
class BMW extends Car {
  val brand = "BMW"
}
```

One class can extend several traits using the <code>with</code> keyword:

```scala
class BMW extends Car with Shiny {
  val brand = "BMW"
  val shineRefraction = 12
}
```

*See Also* Effective Scala has opinions about [trait](http://twitter.github.com/effectivescala/#Object oriented programming-Traits).

*When do you want a Trait instead of an Abstract Class?* If you want to define an interface-like type, you might find it difficult to choose between a trait or an abstract class. Either one lets you define a type with some behavior, asking extenders to define some other behavior. Some rules of thumb:

<ul>
<li>Favor using traits. It's handy that a class can extend several traits; a class can extend only one class.
<li>If you need a constructor parameter, use an abstract class. Abstract class constructors can take parameters; trait constructors can't. For example, you can't say <code>trait t(i: Int) {}</code>; the <code>i</code> parameter is illegal.
</ul>

You are not the first person to ask this question. See fuller answers at "stackoverflow:Scala traits vs abstract classes":http://stackoverflow.com/questions/1991042/scala-traits-vs-abstract-classes, "Difference between Abstract Class and Trait":http://stackoverflow.com/questions/2005681/difference-between-abstract-class-and-trait, and "Programming in Scala: To trait, or not to trait?":http://www.artima.com/pins1ed/traits.html#12.7

---

# Types

Earlier, you saw that we defined a function that took an <code>Int</code> which is a type of Number. Functions can also be generic and work on any type. When that occurs, you'll see a type parameter introduced with the square bracket syntax. Here's an example of a Cache of generic Keys and Values.

```scala
trait Cache[K, V] {
  def get(key: K): V
  def put(key: K, value: V)
  def delete(key: K)
}
```

Methods can also have type parameters introduced.

```scala
def remove[K](key: K)
```


# Basics continued

This lesson covers:
* "apply":#apply
* "objects":#object
* "Functions are Objects":#fnobj
* "packages":#package
* "pattern matching":#match
* "case classes":#caseclass
* "try-catch-finally":#exception

---

# apply methods

apply methods give you a nice syntactic sugar for when a class or object has one main use.

```scala
scala> class Foo {}
defined class Foo

scala> object FooMaker {
     |   def apply() = new Foo
     | }
defined module FooMaker

scala> val newFoo = FooMaker()
newFoo: Foo = Foo@5b83f762
```

or

```scala
scala> class Bar {
     |   def apply() = 0
     | }
defined class Bar

scala> val bar = new Bar
bar: Bar = Bar@47711479

scala> bar()
res8: Int = 0
```

Here our instance object looks like we're calling a method. More on that later!

---

# Objects

Objects are used to hold single instances of a class. Often used for factories.

```scala
object Timer {
  var count = 0

  def currentCount(): Long = {
    count += 1
    count
  }
}
```

How to use

```scala
scala> Timer.currentCount()
res0: Long = 1
```

Classes and Objects can have the same name.  The object is called a 'Companion Object'.  We commonly use Companion Objects for Factories.

Here is a trivial example that only serves to remove the need to use 'new' to create an instance.

```scala
class Bar(foo: String)

object Bar {
  def apply(foo: String) = new Bar(foo)
}
```


---

# Functions are Objects

In Scala, we talk about object-functional programming often.  What does that mean? What is a Function, really?

A Function is a set of traits. Specifically, a function that takes one argument is an instance of a Function1 trait. This trait defines the <code>apply()</code> syntactic sugar we learned earlier, allowing you to call an object like you would a function.

```scala
scala> object addOne extends Function1[Int, Int] {
     |   def apply(m: Int): Int = m + 1
     | }
defined module addOne

scala> addOne(1)
res2: Int = 2
```

There is Function1 through 22.  Why 22?  It's an arbitrary magic number.  I've never needed a function with more than 22 arguments so it seems to work out.

The syntactic sugar of apply helps unify the duality of object and functional programming.  You can pass classes around and use them as functions and functions are just instances of classes under the covers.

Does this mean that every time you define a method in your class, you're actually getting an instance of Function*?  No, methods in classes are methods.  Methods defined standalone in the repl are Function* instances.

Classes can also extend Function and those instances can be called with ().

```scala
scala> class AddOne extends Function1[Int, Int] {
     |   def apply(m: Int): Int = m + 1
     | }
defined class AddOne

scala> val plusOne = new AddOne()
plusOne: AddOne = <function1>

scala> plusOne(1)
res0: Int = 2
```

A nice short-hand for <code>extends Function1[Int, Int]</code> is <code>extends (Int => Int)</code>

```scala
class AddOne extends (Int => Int) {
  def apply(m: Int): Int = m + 1
}
```

---

# Packages

You can organize your code inside of packages.

```scala
package com.twitter.example
```

at the top of a file will declare everything in the file to be in that package.

Values and functions cannot be outside of a class or object.  Objects are a useful tool for organizing static functions.

```scala
package com.twitter.example

object colorHolder {
  val BLUE = "Blue"
  val RED = "Red"
}
```

Now you can access the members directly

```scala
println("the color is: " + com.twitter.example.colorHolder.BLUE)
```

Notice what the scala repl says when you define this object:

```scala
scala> object colorHolder {
     |   val Blue = "Blue"
     |   val Red = "Red"
     | }
defined module colorHolder
```

This gives you a small hint that the designers of Scala designed objects to be part of Scala's module system.

---

# Pattern Matching

One of the most useful parts of Scala.

Matching on values

```scala
val times = 1

times match {
  case 1 => "one"
  case 2 => "two"
  case _ => "some other number"
}
```

Matching with guards

```scala
times match {
  case i if i == 1 => "one"
  case i if i == 2 => "two"
  case _ => "some other number"
}
```

Notice how we captured the value in the variable 'i'.

The <code>_</code> in the last case statement is a wildcard; it
ensures that we can handle any statement. Otherwise you will suffer a
runtime error if you pass in a number that doesn't match. We discuss
this more later.

*See Also* Effective Scala has opinions about [when to use pattern matching](http://twitter.github.com/effectivescala/#Functional programming-Pattern matching) and [pattern matching formatting](http://twitter.github.com/effectivescala/#Formatting-Pattern matching). A Tour of Scala describes [Pattern Matching](http://www.scala-lang.org/node/120)

---

# Matching on type

You can use <code>match</code> to handle values of different types differently.

```scala
def bigger(o: Any): Any = {
  o match {
    case i: Int if i < 0 => i - 1
    case i: Int => i + 1
    case d: Double if d < 0.0 => d - 0.1
    case d: Double => d + 0.1
    case text: String => text + "s"
  }
}
```

---

# Matching on class members

Remember our calculator from earlier.

Let's classify them according to type.

Here's the painful way first.

```scala
def calcType(calc: Calculator) = calc match {
  case _ if calc.brand == "hp" && calc.model == "20B" => "financial"
  case _ if calc.brand == "hp" && calc.model == "48G" => "scientific"
  case _ if calc.brand == "hp" && calc.model == "30B" => "business"
  case _ => "unknown"
}
```

Wow, that's painful.  Thankfully Scala provides some nice tools specifically for this.

---

# Case Classes

case classes are used to conveniently store and match on the contents of a class. You can construct them without using new.

```scala
scala> case class Calculator(brand: String, model: String)
defined class Calculator

scala> val hp20b = Calculator("hp", "20b")
hp20b: Calculator = Calculator(hp,20b)

```

case classes automatically have equality and nice toString methods based on the constructor arguments.

```scala
scala> val hp20b = Calculator("hp", "20b")
hp20b: Calculator = Calculator(hp,20b)

scala> val hp20B = Calculator("hp", "20b")
hp20B: Calculator = Calculator(hp,20b)

scala> hp20b == hp20B
res6: Boolean = true
```

case classes can have methods just like normal classes.

h6. Case Classes with pattern matching

case classes are designed to be used with pattern matching.  Let's simplify our calculator classifier example from earlier.

```scala
val hp20b = Calculator("hp", "20B")
val hp30b = Calculator("hp", "30B")

def calcType(calc: Calculator) = calc match {
  case Calculator("hp", "20B") => "financial"
  case Calculator("hp", "48G") => "scientific"
  case Calculator("hp", "30B") => "business"
  case Calculator(ourBrand, ourModel) => "Calculator: %s %s is of unknown type".format(ourBrand, ourModel)
}
```

Other alternatives for that last match

```scala
  case Calculator(_, _) => "Calculator of unknown type"
```

  OR we could simply not specify that it's a Calculator at all.

```scala
  case _ => "Calculator of unknown type"
```

  OR we could re-bind the matched value with another name

```scala
  case c@Calculator(_, _) => "Calculator: %s of unknown type".format(c)
```

---

# Exceptions

Exceptions are available in Scala via a try-catch-finally syntax that uses pattern matching.

```scala
try {
  remoteCalculatorService.add(1, 2)
} catch {
  case e: ServerIsDownException => log.error(e, "the remote calculator service is unavailable. should have kept your trusty HP.")
} finally {
  remoteCalculatorService.close()
}
```

<code>try</code>s are also expression-oriented

```scala
val result: Int = try {
  remoteCalculatorService.add(1, 2)
} catch {
  case e: ServerIsDownException => {
    log.error(e, "the remote calculator service is unavailable. should have kept your trusty HP.")
    0
  }
} finally {
  remoteCalculatorService.close()
}
```

This is not an example of excellent programming style, just an example of try-catch-finally resulting in expressions like most everything else in Scala.

Finally will be called after an exception has been handled and is not part of the expression.

# Collections

This lesson covers:

* Basic Data Structures
    * "Lists":#Lists
    * "Sets":#Sets
    * "Tuple":#Tuple
    * "Maps":#Maps
* Functional Combinators
    * "map":#map
    * "foreach":#foreach
    * "filter":#filter
    * "zip":#zip
    * "partition":#partition
    * "find":#find
    * "drop and dropWhile":#drop
    * "foldRight and foldLeft":#fold
    * "flatten":#flatten
    * "flatMap":#flatMap
    * "Generalized functional combinators":#generalized
    * "Map?":#vsMap

h1. Basic Data Structures

Scala provides some nice collections.

*See Also* Effective Scala has opinions about how to use [collections](http://twitter.github.com/effectivescala/#Collections).

---

# Lists

```scala
scala> val numbers = List(1, 2, 3, 4)
numbers: List[Int] = List(1, 2, 3, 4)
```

---

# Sets

Sets have no duplicates

```scala
scala> Set(1, 1, 2)
res0: scala.collection.immutable.Set[Int] = Set(1, 2)
```

---

# Tuple

A tuple groups together simple logical collections of items without using a class.

```scala
scala> val hostPort = ("localhost", 80)
hostPort: (String, Int) = (localhost, 80)
```

Unlike case classes, they don't have named accessors, instead they have accessors that are named by their position and is 1-based rather than 0-based.

```scala
scala> hostPort._1
res0: String = localhost

scala> hostPort._2
res1: Int = 80
```

Tuples fit with pattern matching nicely.

```scala
hostPort match {
  case ("localhost", port) => ...
  case (host, port) => ...
}
```

Tuple has some special sauce for simply making Tuples of 2 values: <code>-></code>

```scala
scala> 1 -> 2
res0: (Int, Int) = (1,2)
```

*See Also* Effective Scala has opinions about [destructuring bindings](http://twitter.github.com/effectivescala/#Functional programming-Destructuring bindings) ("unpacking" a tuple).

---

# Maps

It can hold basic datatypes.

```scala
Map(1 -> 2)
Map("foo" -> "bar")
```

This looks like special syntax but remember back to our discussion of Tuple that <code>-></code> can be use to create Tuples.

Map() also uses that variable argument syntax we learned back in Lesson #1: <code>Map(1 -> "one", 2 -> "two")</code> which expands into <code>Map((1, "one"), (2, "two"))</code> with the first element being the key and the second being the value of the Map.

Maps can themselves contain Maps or even functions as values.

```scala
Map(1 -> Map("foo" -> "bar"))
```

```scala
Map("timesTwo" -> { timesTwo(_) })
```

---

# Option

<code>Option</code> is a container that may or may not hold something.

The basic interface for Option looks like:

<code>
trait Option[T] {
  def isDefined: Boolean
  def get: T
  def getOrElse(t: T): T
}
</code>

Option itself is generic and has two subclasses: <code>Some[T]</code> or <code>None</code>

Let's look at an example of how Option is used:

<code>Map.get</code> uses <code>Option</code> for its return type. Option tells you that the method might not return what you're asking for.

```scala
scala> val numbers = Map(1 -> "one", 2 -> "two")
numbers: scala.collection.immutable.Map[Int,String] = Map((1,one), (2,two))

scala> numbers.get(2)
res0: Option[java.lang.String] = Some(two)

scala> numbers.get(3)
res1: Option[java.lang.String] = None
```

Now our data appears trapped in this <code>Option</code>. How do we work with it?

A first instinct might be to do something conditionally based on the <code>isDefined</code> method.

<code>
// We want to multiply the number by two, otherwise return 0.
val result = if (res1.isDefined) {
  res1.get * 2
} else {
  0
}
</code>

We would suggest that you use either <code>getOrElse</code> or pattern matching to work with this result.

<code>getOrElse</code> lets you easily define a default value.

<code>
val result = res1.getOrElse(0) * 2
</code>

Pattern matching fits naturally with <code>Option</code>.

<code>
val result = res1 match {
  case Some(n) => n * 2
  case None => 0
}
</code>

*See Also* Effective Scala has opinions about [Options](http://twitter.github.com/effectivescala/#Functional programming-Options).

h1(#combinators). Functional Combinators

<code>List(1, 2, 3) map squared</code> applies the function <code>squared</code> to the elements of the the list, returning a new list, perhaps <code>List(1, 4, 9)</code>. We call operations like <code>map</code> <em>combinators</em>. (If you'd like a better definition, you might like [Explanation of combinators](http://stackoverflow.com/questions/7533837/explanation-of-combinators-for-the-working-man) on Stackoverflow.) Their most common use is on the standard data structures.

---

# map

Evaluates a function over each element in the list, returning a list with the same number of elements.

```scala
scala> numbers.map((i: Int) => i * 2)
res0: List[Int] = List(2, 4, 6, 8)
```

or pass in a partially evaluated function

```scala

scala> def timesTwo(i: Int): Int = i * 2
timesTwo: (i: Int)Int

scala> numbers.map(timesTwo _)
res0: List[Int] = List(2, 4, 6, 8)
```

---

# foreach

foreach is like map but returns nothing. foreach is intended for side-effects only.

```scala
scala> numbers.foreach((i: Int) => i * 2)
```

returns nothing.

You can try to store the return in a value but it'll be of type Unit (i.e. void)

```scala
scala> val doubled = numbers.foreach((i: Int) => i * 2)
doubled: Unit = ()
```

---

# filter

removes any elements where the function you pass in evaluates to false.  Functions that return a Boolean are often called predicate functions.

```scala
scala> numbers.filter((i: Int) => i % 2 == 0)
res0: List[Int] = List(2, 4)
```

```scala
scala> def isEven(i: Int): Boolean = i % 2 == 0
isEven: (i: Int)Boolean

scala> numbers.filter(isEven _)
res2: List[Int] = List(2, 4)
```

---

# zip

zip aggregates the contents of two lists into a single list of pairs.

```scala
scala> List(1, 2, 3).zip(List("a", "b", "c"))
res0: List[(Int, String)] = List((1,a), (2,b), (3,c))
```

---

# partition

<code>partition</code> splits a list based on where it falls with respect to a predicate function.

```scala
scala> val numbers = List(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)
scala> numbers.partition(_ %2 == 0)
res0: (List[Int], List[Int]) = (List(2, 4, 6, 8, 10),List(1, 3, 5, 7, 9))
```

---

# find

find returns the first element of a collection that matches a predicate function.

```scala
scala> numbers.find((i: Int) => i > 5)
res0: Option[Int] = Some(6)
```

---

# drop & dropWhile

<code>drop</code> drops the first i elements

```scala
scala> numbers.drop(5)
res0: List[Int] = List(6, 7, 8, 9, 10)
```

<code>dropWhile</code> removes the first elements that match a predicate function. For example, if we <code>dropWhile</code> odd numbers from our list of numbers, <code>1</code> gets dropped (but not <code>3</code> which is "shielded" by <code>2</code>).

```scala
scala> numbers.dropWhile(_ % 2 != 0)
res0: List[Int] = List(2, 3, 4, 5, 6, 7, 8, 9, 10)
```

---

# foldLeft

```scala
scala> numbers.foldLeft(0)((m: Int, n: Int) => m + n)
res0: Int = 55
```

0 is the starting value (Remember that numbers is a List[Int]), and m
acts as an accumulator.

Seen visually:

```scala
scala> numbers.foldLeft(0) { (m: Int, n: Int) => println("m: " + m + " n: " + n); m + n }
m: 0 n: 1
m: 1 n: 2
m: 3 n: 3
m: 6 n: 4
m: 10 n: 5
m: 15 n: 6
m: 21 n: 7
m: 28 n: 8
m: 36 n: 9
m: 45 n: 10
res0: Int = 55
```

---

# foldRight

Is the same as foldLeft except it runs in the opposite direction.

```scala
scala> numbers.foldRight(0) { (m: Int, n: Int) => println("m: " + m + " n: " + n); m + n }
m: 10 n: 0
m: 9 n: 10
m: 8 n: 19
m: 7 n: 27
m: 6 n: 34
m: 5 n: 40
m: 4 n: 45
m: 3 n: 49
m: 2 n: 52
m: 1 n: 54
res0: Int = 55
```

---

# flatten

flatten collapses one level of nested structure.

```scala
scala> List(List(1, 2), List(3, 4)).flatten
res0: List[Int] = List(1, 2, 3, 4)
```

---

# flatMap

flatMap is a frequently used combinator that combines mapping and flattening. flatMap takes a function that works on the nested lists and then concatenates the results back together.

```scala
scala> val nestedNumbers = List(List(1, 2), List(3, 4))
nestedNumbers: List[List[Int]] = List(List(1, 2), List(3, 4))

scala> nestedNumbers.flatMap(x => x.map(_ * 2))
res0: List[Int] = List(2, 4, 6, 8)
```

Think of it as short-hand for mapping and then flattening:

```scala
scala> nestedNumbers.map((x: List[Int]) => x.map(_ * 2)).flatten
res1: List[Int] = List(2, 4, 6, 8)
```

that example calling map and then flatten is an example of the "combinator"-like nature of these functions.

*See Also* Effective Scala has opinions about [flatMap](http://twitter.github.com/effectivescala/#Functional programming-`flatMap`).

---

# Generalized functional combinators

Now we've learned a grab-bag of functions for working with collections.

What we'd like is to be able to write our own functional combinators.

Interestingly, every functional combinator shown above can be written on top of fold.  Let's see some examples.

```scala
def ourMap(numbers: List[Int], fn: Int => Int): List[Int] = {
  numbers.foldRight(List[Int]()) { (x: Int, xs: List[Int]) =>
    fn(x) :: xs
  }
}

scala> ourMap(numbers, timesTwo(_))
res0: List[Int] = List(2, 4, 6, 8, 10, 12, 14, 16, 18, 20)
```

Why <tt>List[Int]()</tt>? Scala wasn't smart enough to realize that you wanted an empty list of Ints to accumulate into.

---

# Map?

All of the functional combinators shown work on Maps, too.  Maps can be thought of as a list of pairs so the functions you write work on a pair of the keys and values in the Map.

```scala
scala> val extensions = Map("steve" -> 100, "bob" -> 101, "joe" -> 201)
extensions: scala.collection.immutable.Map[String,Int] = Map((steve,100), (bob,101), (joe,201))
```

Now filter out every entry whose phone extension is lower than 200.

```scala
scala> extensions.filter((namePhone: (String, Int)) => namePhone._2 < 200)
res0: scala.collection.immutable.Map[String,Int] = Map((steve,100), (bob,101))
```

Because it gives you a tuple, you have to pull out the keys and values with their positional accessors. Yuck!

Lucky us, we can actually use a pattern match to extract the key and value nicely.

```scala
scala> extensions.filter({case (name, extension) => extension < 200})
res0: scala.collection.immutable.Map[String,Int] = Map((steve,100), (bob,101))
```

Why does this work? Why can you pass in a partial pattern match?

Stay tuned for next week!


---

# Pattern matching & functional composition

This lesson covers:

* "Function Composition":#composition
    * compose
    * andThen
* "Currying vs Partial Application":#curryvspartial
* "PartialFunctions":#PartialFunction
    * range and domain
    * composition with orElse
* "What is a case statement?":#case

---

# Function Composition

Let's make two aptly-named functions:

```scala
scala> def f(s: String) = "f(" + s + ")"
f: (String)java.lang.String

scala> def g(s: String) = "g(" + s + ")"
g: (String)java.lang.String
```

---

# compose

<code>compose</code> makes a new function that composes other functions <code>f(g(x))</code>

```scala
scala> val fComposeG = f _ compose g _
fComposeG: (String) => java.lang.String = <function>

scala> fComposeG("yay")
res0: java.lang.String = f(g(yay))
```

---

# andThen

<code>andThen</code> is like <code>compose</code>, but calls the first function and then the second, <code>g(f(x))</code>

```scala
scala> val fAndThenG = f _ andThen g _
fAndThenG: (String) => java.lang.String = <function>

scala> fAndThenG("yay")
res1: java.lang.String = g(f(yay))
```

---

# Currying vs Partial Application

---

# case statements

### So just what are case statements?

It's a subclass of function called a PartialFunction.

### What is a collection of multiple case statements?

They are multiple PartialFunctions composed together.

---

# Understanding PartialFunction

A function works for every argument of the defined type. In other words, a function defined as (Int) => String takes any Int and returns a String.

A Partial Function is only defined for certain values of the defined type.  A Partial Function (Int) => String might not accept every Int.

<code>isDefinedAt</code> is a method on PartialFunction that can be used to determine if the PartialFunction will accept a given argument.

__Note__ <code>PartialFunction</code> is unrelated to a partially applied function that we talked about earlier.

*See Also* Effective Scala has opinions about [PartialFunction](http://twitter.github.com/effectivescala/#Functional programming-Partial functions).

```scala
scala> val one: PartialFunction[Int, String] = { case 1 => "one" }
one: PartialFunction[Int,String] = <function1>

scala> one.isDefinedAt(1)
res0: Boolean = true

scala> one.isDefinedAt(2)
res1: Boolean = false
```

You can apply a partial function.

```scala
scala> one(1)
res2: String = one
```

PartialFunctions can be composed with something new, called orElse, that reflects whether the PartialFunction is defined over the supplied argument.

```scala
scala> val two: PartialFunction[Int, String] = { case 2 => "two" }
two: PartialFunction[Int,String] = <function1>

scala> val three: PartialFunction[Int, String] = { case 3 => "three" }
three: PartialFunction[Int,String] = <function1>

scala> val wildcard: PartialFunction[Int, String] = { case _ => "something else" }
wildcard: PartialFunction[Int,String] = <function1>

scala> val partial = one orElse two orElse three orElse wildcard
partial: PartialFunction[Int,String] = <function1>

scala> partial(5)
res24: String = something else

scala> partial(3)
res25: String = three

scala> partial(2)
res26: String = two

scala> partial(1)
res27: String = one

scala> partial(0)
res28: String = something else
```

h3(#case). The mystery of case.

Last week we saw something curious. We saw a case statement used where a function is normally used.

```scala
scala> case class PhoneExt(name: String, ext: Int)
defined class PhoneExt

scala> val extensions = List(PhoneExt("steve", 100), PhoneExt("robey", 200))
extensions: List[PhoneExt] = List(PhoneExt(steve,100), PhoneExt(robey,200))

scala> extensions.filter { case PhoneExt(name, extension) => extension < 200 }
res0: List[PhoneExt] = List(PhoneExt(steve,100))
```

Why does this work?

filter takes a function. In this case a predicate function of (PhoneExt) => Boolean.

A PartialFunction is a subtype of Function so filter can also take a PartialFunction!

---

prev: pattern-matching-and-functional-composition.textile
next: advanced-types.textile
title: Type & polymorphism basics
layout: post
---

This lesson covers:

* "What are static types?":#background
* "Types in Scala":#scala
* "Parametric Polymorphism":#parametricpoly
* "Type inference: Hindley-Milner vs. local type inference":#inference
* "Variance":#variance
* "Bounds":#bounds
* "Quantification":#quantification

---

# What are static types?  Why are they useful?

According to Pierce: "A type system is a syntactic method for automatically checking the absence of certain erroneous behaviors by classifying program phrases according to the kinds of values they compute."

Types allow you to denote function domain & codomains. For example, from mathematics, we are used to seeing:

```scala
f: R -> N
```

this tells us that function "f" maps values from the set of real numbers to values of the set of natural numbers.

In the abstract, this is exactly what _concrete_ types are.  Type systems give us some more powerful ways to express these sets.

Given these annotations, the compiler can now _statically_ (at compile time) verify that the program is _sound_. That is, compilation will fail if values (at runtime) will not comply to the constraints imposed by the program.

Generally speaking, the typechecker can only guarantee that _unsound_ programs do not compile. It cannot guarantee that every sound program _will_ compile.

With increasing expressiveness in type systems, we can produce more reliable code because it allows us to prove invariants about our program before it even runs (modulo bugs in the types themselves, of course!). Academia is pushing the limits of expressiveness very hard, including value-dependent types!

Note that all type information is removed at compile time. It is no longer needed. This is called erasure.

---

# Types in Scala

Scala's powerful type system allows for very rich expression. Some of its chief features are:

* *parametric polymorphism* roughly, generic programming
* *(local) type inference* roughly, why you needn't say <code>val i: Int = 12: Int</code>
* *existential quantification* roughly, defining something _for some_ unnamed type
* *views* we'll learn these next week; roughly, "castability" of values of one type to another

---

# Scala Type System

* Everything extends from ```Any``` either through ```AnyRef``` or ```AnyVal```
* ```Nothing``` extends from everything (and is the only class that may extend from both ```AnyRef``` and ```AnyVal```)

.center[![Scala Type System](http://joelabrahamsson.com/PageFiles/148/1310_1644.jpg)]

http://joelabrahamsson.com/learning-scala-part-eight-scalas-type-hierarchy-and-object-equality/

---

# Parametric polymorphism

Polymorphism is used in order to write generic code (for values of different types) without compromising static typing richness.

For example, without parametric polymorphism, a generic list data structure would always look like this (and indeed it did look like this in Java prior to generics):

```scala
scala> 2 :: 1 :: "bar" :: "foo" :: Nil
res5: List[Any] = List(2, 1, bar, foo)
```

Now we cannot recover any type information about the individual members.

```scala
scala> res5.head
res6: Any = 2
```

And so our application would devolve into a series of casts ("asInstanceOf[]") and we would lack type safety (because these are all dynamic).

Polymorphism is achieved through specifying _type variables_.

```scala
scala> def drop1[A](l: List[A]) = l.tail
drop1: [A](l: List[A])List[A]

scala> drop1(List(1,2,3))
res1: List[Int] = List(2, 3)
```

---

# Scala has rank-1 polymorphism

Roughly, this means that there are some type concepts you'd like to express in Scala that are "too generic" for the compiler to understand. Suppose you had some function

```scala
def toList[A](a: A) = List(a)
```

which you wished to use generically:

```scala
def foo[A, B](f: A => List[A], b: B) = f(b)
```

This does not compile, because all type variables have to be fixed at the invocation site. Even if you "nail down" type <code>B</code>,

```scala
def foo[A](f: A => List[A], i: Int) = f(i)
```

...you get a type mismatch.

---

# Type inference

A traditional objection to static typing is that it has much syntactic overhead. Scala alleviates this by providing _type inference_.

The classic method for type inference in functional programming languages is _Hindley-Milner_, and it was first employed in ML.

Scala's type inference system works a little differently, but it's similar in spirit: infer constraints, and attempt to unify a type.

In Scala, for example, you cannot do the following:

```scala
scala> { x => x }
<console>:7: error: missing parameter type
       { x => x }
```

In scala all type inference is _local_. Scala considers one expression at a time. For example:

```scala
scala> def id[T](x: T) = x
id: [T](x: T)T

scala> val x = id(322)
x: Int = 322

scala> val x = id("hey")
x: java.lang.String = hey

scala> val x = id(Array(1,2,3,4))
x: Array[Int] = Array(1, 2, 3, 4)
```

Types are now preserved, The Scala compiler infers the type parameter for us. Note also how we did not have to specify the return type explicitly.

---

# Variance

Scala's type system has to account for class hierarchies together with polymorphism.  Class hierarchies allow the expression of subtype relationships. A central question that comes up when mixing OO with polymorphism is: if <tt>T'</tt> is a subclass of <tt>T</tt>, is <tt>Container[T']</tt> considered a subclass of <tt>Container[T]</tt>? Variance annotations allow you to express the following relationships between class hierarchies & polymorphic types:

|                |*Meaning*                     | *Scala notation*|
|*covariant*     |C[T'] is a subclass of C[T]   | [+T]|
|*contravariant* |C[T] is a subclass of C[T']   | [-T]|
|*invariant*     |C[T] and C[T'] are not related| [T]|

The subtype relationship really means: for a given type T, if T' is a subtype, can you substitute it?

```scala
scala> class Covariant[+A]
defined class Covariant

scala> val cv: Covariant[AnyRef] = new Covariant[String]
cv: Covariant[AnyRef] = Covariant@4035acf6

scala> val cv: Covariant[String] = new Covariant[AnyRef]
<console>:6: error: type mismatch;
 found   : Covariant[AnyRef]
 required: Covariant[String]
       val cv: Covariant[String] = new Covariant[AnyRef]
                                   ^
```

```scala
scala> class Contravariant[-A]
defined class Contravariant

scala> val cv: Contravariant[String] = new Contravariant[AnyRef]
cv: Contravariant[AnyRef] = Contravariant@49fa7ba

scala> val fail: Contravariant[AnyRef] = new Contravariant[String]
<console>:6: error: type mismatch;
 found   : Contravariant[String]
 required: Contravariant[AnyRef]
       val fail: Contravariant[AnyRef] = new Contravariant[String]
                                     ^
```

Contravariance seems strange. When is it used? Somewhat surprising!

```scala
trait Function1 [-T1, +R] extends AnyRef
```

If you think about this from the point of view of substitution, it makes a lot of sense. Let's first define a simple class hierarchy:

```scala
scala> class Animal { val sound = "rustle" }
defined class Animal

scala> class Bird extends Animal { override val sound = "call" }
defined class Bird

scala> class Chicken extends Bird { override val sound = "cluck" }
defined class Chicken
```

Suppose you need a function that takes a <code>Bird</code> param:

```scala
scala> val getTweet: (Bird => String) = // TODO
```

The standard animal library has a function that does what you want, but it takes an <code>Animal</code> parameter instead.  In most situations, if you say "I need a ___, I have a subclass of ___", you're OK. But function parameters are contravariant. If you need a function that takes a <code>Bird</code> and you have a function that takes an <code>Chicken</code>, that function would choke on a <code>Duck</code>. But a function that takes an <code>Animal</code> is OK:

```scala
scala> val getTweet: (Bird => String) = ((a: Animal) => a.sound )
getTweet: Bird => String = <function1>
```

A function's return value type is covariant. If you need a function that returns a <code>Bird</code> but have a function that returns a <code>Chicken</code>, that's great.

```scala
scala> val hatch: (() => Bird) = (() => new Chicken )
hatch: () => Bird = <function0>
```

---

# Bounds

Scala allows you to restrict polymorphic variables using _bounds_. These bounds express subtype relationships.

```scala
scala> def cacophony[T](things: Seq[T]) = things map (_.sound)
<console>:7: error: value sound is not a member of type parameter T
       def cacophony[T](things: Seq[T]) = things map (_.sound)
                                                        ^

scala> def biophony[T <: Animal](things: Seq[T]) = things map (_.sound)
biophony: [T <: Animal](things: Seq[T])Seq[java.lang.String]

scala> biophony(Seq(new Chicken, new Bird))
res5: Seq[java.lang.String] = List(cluck, call)
```

Lower type bounds are also supported; they come in handy with contravariance and clever covariance. <code>List[+T]</code> is covariant; a list of Birds is a list of Animals. <code>List</code> defines an operator <code>::(elem T)</code> that returns a new <code>List</code> with <code>elem</code> prepended. The new <code>List</code> has the same type as the original:

```scala
scala> val flock = List(new Bird, new Bird)
flock: List[Bird] = List(Bird@7e1ec70e, Bird@169ea8d2)

scala> new Chicken :: flock
res53: List[Bird] = List(Chicken@56fbda05, Bird@7e1ec70e, Bird@169ea8d2)
```

<code>List</code> _also_ defines <code>::[B >: T](x: B)</code> which returns a <code>List[B]</code>. Notice the <code>B >: T</code>. That specifies type <code>B</code> as a superclass of <code>T</code>. That lets us do the right thing when prepending an <code>Animal</code> to a <code>List[Bird]</code>:

```scala
scala> new Animal :: flock
res59: List[Animal] = List(Animal@11f8d3a8, Bird@7e1ec70e, Bird@169ea8d2)
```

Note that the return type is <code>Animal</code>.

---

# Quantification

Sometimes you do not care to be able to name a type variable, for example:

```scala
scala> def count[A](l: List[A]) = l.size
count: [A](List[A])Int
```

Instead you can use "wildcards":

```scala
scala> def count(l: List[_]) = l.size
count: (List[_])Int
```

This is shorthand for:

```scala
scala> def count(l: List[T forSome { type T }]) = l.size
count: (List[T forSome { type T }])Int
```

Note that quantification can get tricky:

```scala
scala> def drop1(l: List[_]) = l.tail
drop1: (List[_])List[Any]
```

Suddenly we lost type information! To see what's going on, revert to the heavy-handed syntax:

```scala
scala> def drop1(l: List[T forSome { type T }]) = l.tail
drop1: (List[T forSome { type T }])List[T forSome { type T }]
```

We can't say anything about T because the type does not allow it.

You may also apply bounds to wildcard type variables:

```scala
scala> def hashcodes(l: Seq[_ <: AnyRef]) = l map (_.hashCode)
hashcodes: (Seq[_ <: AnyRef])Seq[Int]

scala> hashcodes(Seq(1,2,3))
<console>:7: error: type mismatch;
 found   : Int(1)
 required: AnyRef
Note: primitive types are not implicitly converted to AnyRef.
You can safely force boxing by casting x.asInstanceOf[AnyRef].
       hashcodes(Seq(1,2,3))
                     ^

scala> hashcodes(Seq("one", "two", "three"))
res1: Seq[Int] = List(110182, 115276, 110339486)
```

*See Also* [Existential types in Scala by D. R. MacIver](http://www.drmaciver.com/2008/03/existential-types-in-scala/)

---

# View bounds ("type classes")

Sometimes you don't need to specify that one type is equal/sub/super another, just that you could fake it with conversions. A view bound specifies a type that can be "viewed as" another. This makes sense for an operation that needs to "read" an object but doesn't modify the object.

*Implicit* functions allow automatic conversion. More precisely, they allow on-demand function application when this can help satisfy type inference. e.g.:

```scala
scala> implicit def strToInt(x: String) = x.toInt
strToInt: (x: String)Int

scala> "123"
res0: java.lang.String = 123

scala> val y: Int = "123"
y: Int = 123

scala> math.max("123", 111)
res1: Int = 123
```

view bounds, like type bounds demand such a function exists for the given type.  You specify a type bound with <code><%</code> e.g.,

```scala
scala> class Container[A <% Int] { def addIt(x: A) = 123 + x }
defined class Container
```

This says that *A* has to be "viewable" as *Int*.  Let's try it.

```scala
scala> (new Container[String]).addIt("123")
res11: Int = 246

scala> (new Container[Int]).addIt(123) 
res12: Int = 246

scala> (new Container[Float]).addIt(123.2F)
<console>:8: error: could not find implicit value for evidence parameter of type (Float) => Int
       (new Container[Float]).addIt(123.2)
        ^
```

---

# Other type bounds

Methods can enforce more complex type bounds via implicit parameters. For example, <code>List</code> supports <code>sum</code> on numeric contents but not on others. Alas, Scala's numeric types don't all share a superclass, so we can't just say <code>T <: Number</code>. Instead, to make this work, Scala's math library <a href="http://www.azavea.com/blogs/labs/2011/06/scalas-numeric-type-class-pt-1/">defines an implicit <code>Numeric[T]</code> for the appropriate types T</a>.  Then in <code>List</code>'s definition uses it:

```scala
sum[B >: A](implicit num: Numeric[B]): B
```

If you invoke <code>List(1,2).sum()</code>, you don't need to pass a _num_ parameter; it's set implicitly. But if you invoke <code>List("whoop").sum()</code>, it complains that it couldn't set <code>num</code>.

Methods may ask for some kinds of specific "evidence" for a type without setting up strange objects as with <code>Numeric</code>. Instead, you can use of these type-relation operators:

|A =:= B|A must be equal to B|
|A <:< B|A must be a subtype of B|
|A <%< B|A must be viewable as B|

```scala
scala> class Container[A](value: A) { def addIt(implicit evidence: A =:= Int) = 123 + value }
defined class Container

scala> (new Container(123)).addIt
res11: Int = 246

scala> (new Container("123")).addIt
<console>:10: error: could not find implicit value for parameter evidence: =:=[java.lang.String,Int]
```

Similarly, given our previous implicit, we can relax the constraint to viewability:

```scala
scala> class Container[A](value: A) { def addIt(implicit evidence: A <%< Int) = 123 + value }
defined class Container

scala> (new Container("123")).addIt
res15: Int = 246
```

---

# Generic programming with views

In the Scala standard library, views are primarily used to implement generic functions over collections.  For example, the "min" function (on *Seq[]*), uses this technique:

```scala
def min[B >: A](implicit cmp: Ordering[B]): A = {
  if (isEmpty)
    throw new UnsupportedOperationException("empty.min")

  reduceLeft((x, y) => if (cmp.lteq(x, y)) x else y)
}
```

The main advantages of this are:

* Items in the collections aren't required to implement *Ordered*, but *Ordered* uses are still statically type checked.
* You can define your own orderings without any additional library support:

```scala
scala> List(1,2,3,4).min
res0: Int = 1

scala> List(1,2,3,4).min(new Ordering[Int] { def compare(a: Int, b: Int) = b compare a })
res3: Int = 4
```

As a sidenote, there are views in the standard library that translates *Ordered* into *Ordering* (and vice versa).

```scala
trait LowPriorityOrderingImplicits {
  implicit def ordered[A <: Ordered[A]]: Ordering[A] = new Ordering[A] {
    def compare(x: A, y: A) = x.compare(y)
  }
}
```

### Context bounds & implicitly[]

Scala 2.8 introduced a shorthand for threading through & accessing implicit arguments.

```scala
scala> def foo[A](implicit x: Ordered[A]) {}
foo: [A](implicit x: Ordered[A])Unit

scala> def foo[A : Ordered] {}                        
foo: [A](implicit evidence$1: Ordered[A])Unit
```

Implicit values may be accessed via *implicitly*

```scala
scala> implicitly[Ordering[Int]]
res37: Ordering[Int] = scala.math.Ordering$Int$@3a9291cf
```

Combined, these often result in less code, especially when threading through views.

---

# Higher-kinded types & ad-hoc polymorphism

Scala can abstract over "higher kinded" types. For example, suppose that you needed to use several types of containers for several types of data. You might define a <code>Container</code> interface that might be implemented by means of several container types: an <code>Option</code>, a <code>List</code>, etc. You want to define an interface for using values in these containers without nailing down the values' type.

This is analogous to function currying. For example, whereas "unary types" have constructors like <code>List[A]</code>, meaning we have to satisfy one "level" of type variables in order to produce a concrete types (just like an uncurried function needs to be supplied by only one argument list to be invoked), a higher-kinded type needs more.

```scala
scala> trait Container[M[_]] { def put[A](x: A): M[A]; def get[A](m: M[A]): A }

scala> val container = new Container[List] { def put[A](x: A) = List(x); def get[A](m: List[A]) = m.head }
container: java.lang.Object with Container[List] = $anon$1@7c8e3f75

scala> container.put("hey")
res24: List[java.lang.String] = List(hey)

scala> container.put(123)
res25: List[Int] = List(123)
```

Note that *Container* is polymorphic in a parameterized type ("container type").

If we combine using containers with implicits, we get "ad-hoc" polymorphism: the ability to write generic functions over containers.

```scala
scala> trait Container[M[_]] { def put[A](x: A): M[A]; def get[A](m: M[A]): A }

scala> implicit val listContainer = new Container[List] { def put[A](x: A) = List(x); def get[A](m: List[A]) = m.head }

scala> implicit val optionContainer = new Container[Some] { def put[A](x: A) = Some(x); def get[A](m: Some[A]) = m.get }

scala> def tupleize[M[_]: Container, A, B](fst: M[A], snd: M[B]) = {
     | val c = implicitly[Container[M]]                             
     | c.put(c.get(fst), c.get(snd))
     | }
tupleize: [M[_],A,B](fst: M[A],snd: M[B])(implicit evidence$1: Container[M])M[(A, B)]

scala> tupleize(Some(1), Some(2))
res33: Some[(Int, Int)] = Some((1,2))

scala> tupleize(List(1), List(2))
res34: List[(Int, Int)] = List((1,2))
```

---

# F-bounded polymorphism

Often it's necessary to access a concrete subclass in a (generic) trait. For example, imagine you had some trait that is generic, but can be compared to a particular subclass of that trait.

```scala
trait Container extends Ordered[Container]
```

However, this now necessitates the compare method

```scala
def compare(that: Container): Int
```

And so we cannot access the concrete subtype, e.g.:

```scala
class MyContainer extends Container {
  def compare(that: MyContainer): Int
}
```

fails to compile, since we are specifying Ordered for *Container*, not the particular subtype.

To reconcile this, we instead use F-bounded polymorphism.

```scala
trait Container[A <: Container[A]] extends Ordered[A]
```

Strange type!  But note now how Ordered is parameterized on *A*, which itself is *Container[A]*

So, now 

```scala
class MyContainer extends Container[MyContainer] { 
  def compare(that: MyContainer) = 0 
}
```

They are now ordered:

```scala
scala> List(new MyContainer, new MyContainer, new MyContainer)
res3: List[MyContainer] = List(MyContainer@30f02a6d, MyContainer@67717334, MyContainer@49428ffa)

scala> List(new MyContainer, new MyContainer, new MyContainer).min
res4: MyContainer = MyContainer@33dfeb30
```

Given that they are all subtypes of *Container[_]*, we can define another subclass & create a mixed list of *Container[_]*:

```scala
scala> class YourContainer extends Container[YourContainer] { def compare(that: YourContainer) = 0 }
defined class YourContainer

scala> List(new MyContainer, new MyContainer, new MyContainer, new YourContainer)                   
res2: List[Container[_ >: YourContainer with MyContainer <: Container[_ >: YourContainer with MyContainer <: ScalaObject]]] 
  = List(MyContainer@3be5d207, MyContainer@6d3fe849, MyContainer@7eab48a7, YourContainer@1f2f0ce9)
```

Note how the resulting type is now lower-bound by *YourContainer with MyContainer*. This is the work of the type inferencer. Interestingly- this type doesn't even need to make sense, it only provides a logical greatest lower bound for the unified type of the list. What happens if we try to use *Ordered* now?

```scala
(new MyContainer, new MyContainer, new MyContainer, new YourContainer).min
<console>:9: error: could not find implicit value for parameter cmp:
  Ordering[Container[_ >: YourContainer with MyContainer <: Container[_ >: YourContainer with MyContainer <: ScalaObject]]]
```

No *Ordered[]* exists for the unified type. Too bad.

---

# Structural types

Scala has support for *structural types* -- type requirements are expressed by interface _structure_ instead of a concrete type.

```scala
scala> def foo(x: { def get: Int }) = 123 + x.get
foo: (x: AnyRef{def get: Int})Int

scala> foo(new { def get = 10 })                 
res0: Int = 133
```

This can be quite nice in many situations, but the implementation uses reflection, so be performance-aware!

---

# Abstract type members

In a trait, you can leave type members abstract.

```scala
scala> trait Foo { type A; val x: A; def getX: A = x }
defined trait Foo

scala> (new Foo { type A = Int; val x = 123 }).getX   
res3: Int = 123

scala> (new Foo { type A = String; val x = "hey" }).getX
res4: java.lang.String = hey
```

This is often a useful trick when doing dependency injection, etc.

You can refer to an abstract type variable using the hash-operator:

```scala
scala> trait Foo[M[_]] { type t[A] = M[A] }
defined trait Foo

scala> val x: Foo[List]#t[Int] = List(1)
x: List[Int] = List(1)
```


---

# Type erasures & manifests

As we know, type information is lost at compile time due to _erasure_. Scala features *Manifests*, allowing us to selectively recover type information. Manifests are provided as an implicit value, generated by the compiler as needed.

```scala
scala> class MakeFoo[A](implicit manifest: Manifest[A]) {
     |   def make: A = manifest.erasure.newInstance.asInstanceOf[A]
     | }

scala> (new MakeFoo[String]).make
res10: String = ""
```

---

# Case study: Finagle

See: https://github.com/twitter/finagle

```scala
trait Service[-Req, +Rep] extends (Req => Future[Rep])

trait Filter[-ReqIn, +RepOut, +ReqOut, -RepIn]
  extends ((ReqIn, Service[ReqOut, RepIn]) => Future[RepOut])
{
  def andThen[Req2, Rep2](next: Filter[ReqOut, RepIn, Req2, Rep2]) =
    new Filter[ReqIn, RepOut, Req2, Rep2] {
      def apply(request: ReqIn, service: Service[Req2, Rep2]) = {
        Filter.this.apply(request, new Service[ReqOut, RepIn] {
          def apply(request: ReqOut): Future[RepIn] = next(request, service)
          override def release() = service.release()
          override def isAvailable = service.isAvailable
        })
      }
    }
    
  def andThen(service: Service[ReqOut, RepIn]) = new Service[ReqIn, RepOut] {
    private[this] val refcounted = new RefcountedService(service)

    def apply(request: ReqIn) = Filter.this.apply(request, refcounted)
    override def release() = refcounted.release()
    override def isAvailable = refcounted.isAvailable
  }    
}
```

A service may authenticate requests with a filter.

```scala
trait RequestWithCredentials extends Request {
  def credentials: Credentials
}

class CredentialsFilter(credentialsParser: CredentialsParser)
  extends Filter[Request, Response, RequestWithCredentials, Response]
{
  def apply(request: Request, service: Service[RequestWithCredentials, Response]): Future[Response] = {
    val requestWithCredentials = new RequestWrapper with RequestWithCredentials {
      val underlying = request
      val credentials = credentialsParser(request) getOrElse NullCredentials
    }

    service(requestWithCredentials)
  }
}
```

Note how the underlying service requires an authenticated request, and that this is statically verified. Filters can thus be thought of as service transformers.

Many filters can be composed together:

```scala
val upFilter =
  logTransaction     andThen
  handleExceptions   andThen
  extractCredentials andThen
  homeUser           andThen
  authenticate       andThen
  route
```

Type safely!

    </textarea>
    <script src="http://gnab.github.com/remark/downloads/remark-0.5.1.min.js" type="text/javascript">
    </script>
    <script type="text/javascript">
      var slideshow = remark.create();
    </script>
  </body>
</html>
